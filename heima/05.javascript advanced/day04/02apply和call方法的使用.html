<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>

<body>
	<script>

	</script>

	<script>
		// function f1(x,y){
		// 	console.log((x+y)+":===="+this);
		// 	return "这是函数的返回值";
		// }
		// //apply和call调用
		// var r1 = f1.apply(null,[1,2]);
		// console.log(r1);
		// var r2 = f1.call(null,1,2);//此时f1的this是window
		// console.log(r2);

		// var obj = {
		// 	sex: "男"
		// };
		// var r3 = f1.apply(obj,[1,2]);
		// console.log(r3);
		// var r4 = f1.call(obj,1,2);
		// console.log(r4);


		// function Person(age){
		// 	this.age = age;

		// }
		// Person.prototype.sayHi = function(x,y){
		// 	console.log((x+y)+":====="+this.age);
		// };

		// function Student(age){
		// 	this.age = age;
		// }

		// var per = new Person(10);
		// var stu = new Student(100);
		// //sayHi方法是per实例对象的
		// per.sayHi.apply(stu,[10,20]);
		// per.sayHi.call(stu,10,20);

		//apply和call使用方法
		/*
			apply的使用语法:
			函数名字.apply(对象,[参数1,参数2,...]);
			方法名字.apply(对象,[参数1,参数2,...]);

			call的使用语法:
			函数名字.call(对象,参数1,参数2);
			方法名字.call(对象,参数1,参数2);

			作用:改变this的指向
			不同的地方:参数传递的方式不一样
			只要是想用别的对象的方法,并且希望这个方法是当前对象的,那么就可以使用apply和call的方法来改变this指向

		*/

		function f1() {
			console.log(this + "===>调用了");
		}

		//f1既是实例对象,也是函数
		console.dir(f1);
		f1.apply();
		f1.call();
		console.log(f1.__proto__ == Function.prototype);
		console.dir(Function);




	</script>
</body>

</html>