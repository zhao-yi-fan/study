<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 有 8 张图片 url，你需要并发去获取它，并且任何时刻同时请求的数量不超过 3 个。也就是说第 4 张图片一定是等前面那一批有一个请求完毕了才能开始，以此类推。
    var urls = [
      "https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg",
      "https://www.kkkk1000.com/images/getImgData/gray.gif",
      "https://www.kkkk1000.com/images/getImgData/Particle.gif",
      "https://www.kkkk1000.com/images/getImgData/arithmetic.png",
      "https://www.kkkk1000.com/images/getImgData/arithmetic2.gif",
      "https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg",
      "https://www.kkkk1000.com/images/getImgData/arithmetic.gif",
      "https://www.kkkk1000.com/images/wxQrCode2.png",
    ];

    function loadImg (url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          console.log("一张图片加载完成", url);
          resolve();
        };
        img.onerror = reject;
        img.src = url;
      });
    }

    function limitload (urls, limit) {
      let index = limit;
      function exctor () {
        index++;
        if (index < urls.length) {
          loadImg(urls[index]).then(() => exctor());
        }
      }
      for (let i = 0; i <= limit; i++) {
        loadImg(urls[i]).then(() => {
          exctor();
        });
      }
    }

    // 自己写的 三个全部加载完再加载下一个
    /* function limitload (urls, limit) {
      let index = 0;
      function exctor (limit) {
        let proArr = [];
        for (let i = index; i < urls.length; i++) {
          if (i <= index + limit) {
            proArr.push(loadImg(urls[i]))
          }
        }
        let r = Promise.all(proArr)
        r.then(() => {
          index += limit + 1;
          if (index < urls.length) {
            exctor(limit)
          }
        })
      }
      exctor(limit);
    } */

    // limitload(urls, 2);

    /**
     * 并发请求
     * @param {string[]} urls 待请求的url数组
     * @param {numbter} maxNum 最大并发数
     * @returns 
     */
    function concurRequest (urls, maxNum, requestFn = fetch) {
      if (urls.length === 0) return Promise.resolve([]);
      return new Promise((resolve) => {
        let index = 0; // 指向下一次请求的下标
        const result = []; // 存储所有请求的结果
        let count = 0; // 完成当前的请求数量
        async function _request () {
          const i = index;
          const url = urls[index];
          index++;
          try {
            const resp = await requestFn(url);
            result[i] = resp;
          } catch (error) {
            result[i] = error;
          } finally {
            count++;
            if (count === urls.length) {
              resolve(result);
            }
            if (index < urls.length) {
              _request();
            }
          }
        }
        for (let i = 0; i < Math.min(urls.length, maxNum); i++) {
          _request();
        }
      });
    }
    /* concurRequest(urls, 3, loadImg).then((res) => {
      console.log(res);
    }) */
    const urlArr = [];
    for (let i = 1; i <= 20; i++) {
      urlArr.push(`https://jsonplaceholder.typicode.com/todos/${i}`);
    }
    concurRequest(urlArr, 3).then((res) => {
      console.log(res);
    })
  </script>
</body>

</html>