
1. 基础流程操作

   1. 首先创建中央仓库：可以基于gitHub/codding来创建（**最好不要创建空仓库，因为空仓库中没有任何分支，只有提交一次历史信息才会生成msater分支**）
      把开发者都列入仓库的开发群组中，这样每一个开发者用自己的gitHub账号，都有权限操作这个仓库了（当然不这样做也可以，所有开发者用统一的一个账号也可以，为了防止不知道是谁提交的，我们需要让每一个客户端在本地的GIT全局配置中，设置和gitHub相同的用户名和邮箱`git config --global user.name 'xxx'`）
      会收到一封邮件，接受邀请

   2. 创建客户端本地仓库（一个开发者就是一个单独仓库），还需要让本地的仓库和远程仓库保持关联，这样才可以实现后续的信息同步

      - 一般的方式
        `$git init`创建本地仓库
        `$git remote add [远程地址名(默认origin)] [远程仓库GIT地址]`让本地仓库和远程仓库保持连接
        `$git remote -v`查看连接（origin是连接的名称，一般都用这个名字，当然自己可以随便设置）
        `$git remote rm origin`移出本地仓库和远程仓库的链接
        `$git remote update origin`更新链接通道
        增加了一个名为aaa的远程仓库

      - 更简单的方式：只要把远程仓库克隆到本地，就相当于创建本地仓库，并且自动建立了链接，并且把远程仓库中的内容也同步到了本地

        `$git clone [远程仓库地址] [本地仓库文件夹名字]（不写默认是仓库名字）`
        这一步操作相当于上面的三步：创建文件夹之后`$git init`；`$git remote add [远程地址名(默认origin)] [远程仓库git地址]`；`$git pull [git地址名] master`


   3. 各自和中央服务器同步信息
      推送：`$git push origin master`（每一次PUSH之前最好都pull一下：如果有冲突在本地处理一下冲突，然后再推送。**任何一个中央仓库在刚创建时是没有分支的，第一次pull是拉取不了的，第一次push才会创建msater分支**）
      拉取：`$git pull origin master`
      使用**空**中央仓库，A push之后，B pull不下来的原因是A提交了自己的master分支，中央仓库中的master是A的，B指定origin master时，中央仓库中的master是A的，并不是中央仓库的

      下面不是空中央仓库的流程：

