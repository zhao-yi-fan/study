
  // q: http2多路复用是什么
  // a: qiankun的原理 是怎么封装single-spa的
  // a: 把每个微应用都打包成一个个的umd库，然后通过webpack的jsonp异步加载的方式，把每个微应用都加载到主应用中，然后通过路由的方式，把每个微应用都挂载到主应用的dom节点上
  // a: 为什么要用webpack的jsonp异步加载的方式，而不是直接通过script标签的方式
  // a: 因为webpack的jsonp异步加载的方式，可以实现按需加载，而不是一次性把所有的微应用都加载到主应用中
  // a: 为什么要用umd库，而不是直接用esm库
  // a: 因为umd库可以兼容多种模块化规范，比如amd、cmd、esm、commonjs等，而esm库只能兼容esm规范
  // a: 为什么要用webpack的jsonp异步加载的方式，而不是直接通过import()的方式
  // a: 因为import()的方式，只能实现按需加载，但是不能实现按需加载的同时，还能实现按需执行
  // a: 为什么要用webpack的jsonp异步加载的方式，而不是直接通过fetch的方式
  // a: 因为fetch的方式，只能实现按需加载，但是不能实现按需加载的同时，还能实现按需执行
  // a: 是怎么做样式隔离的
  // a: 通过shadow dom的方式，把每个微应用的样式都隔离开来
  // a: 是怎么做事件隔离的
  // a: 通过自定义事件的方式，把每个微应用的事件都隔离开来

  // q: qiankun的优势
  // a: 1. 通过webpack的jsonp异步加载的方式，实现了按需加载，而不是一次性把所有的微应用都加载到主应用中
  // a: 开发之间的依赖关系更加清晰，开发效率更高
  // a: 防止一个微应用的bug，影响到其他微应用

  // q: qiankun 比iframe的优势
  /* 
  iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。

1. url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。
2. UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..
3. 全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。
4. 慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。

其中有的问题比较好解决(问题1)，有的问题我们可以睁一只眼闭一只眼(问题4)，但有的问题我们则很难解决(问题3)甚至无法解决(问题2)，而这些无法解决的问题恰恰又会给产品带来非常严重的体验问题， 最终导致我们舍弃了 iframe 方案。
 */
// q: lerna的作用是什么
// a: 把多个npm包，放到一个仓库中，统一管理
// q: lerna的优势
// a: 1. 通过lerna，可以把多个npm包，放到一个仓库中，统一管理
// a: 2. 版本号的统一管理


// q: vue2和vue3的diff算法不同
// a: vue2的diff算法是递归的，vue3的diff算法是迭代的
// q: vue3的diff算法是迭代的，是怎么实现的
// a: 通过栈的方式，把每个节点都放到栈中，然后通过迭代的方式，把每个节点都取出来，然后进行比较
// q: vue3的diff算法是迭代的，为什么要用迭代的方式，而不是递归的方式
// a: 递归的方式，会导致函数调用栈溢出，而迭代的方式，不会导致函数调用栈溢出
// q: vue3的diff算法是迭代的，为什么要用迭代的方式，而不是用while循环的方式
// a: 用while循环的方式，会导致代码的可读性变差，而用递归的方式，代码的可读性变好
// q: 对象属性上Symbol.iterator属性的作用是什么
// a: 用来标识对象是可迭代的
// q: vue2的diff算法比较新旧dom的方法是什么
// a: 通过递归的方式，把新旧dom都遍历一遍，然后比较新旧dom的差异
// q: vue2的diff算法比较新旧dom的方法是什么


// q: http2除了多路复用还有哪些特性
// a: 1. 二进制分帧
// a: 2. 首部压缩
// a: 3. 服务器推送


// q: https http属于什么知识？
// a: http属于应用层协议
// q: https http属于应用层协议，那么https属于什么协议
// a: https属于传输层协议
// q: https属于传输层协议，那么http2属于什么协议
// a: http2属于应用层协议

// q: 
